
В библиотеках для роутинга используются очень разные способы показа страниц ошибок:

```tsx
// vue-router
const routes = [
  { path: '/:pathMatch(.*)*', name: 'NotFound', component: NotFound }
]

// mobx-router
startRouter(
  routes,
  store,
  { notfound: () => store.router.goTo(YOUR_NOT_FOUND_ROUTE), }
);

// @kitbag/router
export const router = createRouter(routes, {
  rejections: [createRejection({
    type: 'NotFound',
    component: NotFoundPage,
  })]
})
```

Как правило, синтаксис их определения довольно сильно отличается от "обычных страниц",
хотя они ими и являются. Кроме того, роутеры не заставляют их описывать, что может
привести к отображению пустых страниц в браузере либо дефолтным "заглушкам". 

Философия Reactive Route подразумевает, что роутер должен помогать разработчику
не забывать о важных частях приложения, и в данном случае хорошая практика -
потратить 5 минут на создание страницы ошибок (или взять готовую из секции "Примеры").
На них можно переходить стандартно `router.redirect({ name: 'notFound' })` в целях
тестирования или при написании логики приложения.

А `internalError` будет отображена без замены URL в строке браузера, если допущены
синтаксические ошибки при описании жизненного цикла, и в ряде случаев пользователю
достаточно будет перезагрузить страницу. Например, в `beforeEnter` вы описали логику
подключения по Websocket к бэкенду, но в данный момент сервер был перегружен. Пользователь
перезагружает страницу - и подключение успешно, целевая страница отображена.

Но, разумеется, лучше не слишком полагаться на этот механизм - роутер здесь
представляет "последнюю линию обороны", чтобы не был отображен пустой экран, и
обеспечивая дополнительную консистентность приложению.
