# Принцип работы

B **Reactive Route** всего три ключевых структуры с четкими зонами использования.
Их понимание значительно облегчит описание сложных сценариев в ваших проектах.

## Структуры

#### `Config` содержит всю логику работы со страницей

<!-- @include: @shared/introduction/extendedUserConfig.md -->

#### `Payload` содержит значения для определенного `Config`

```tsx
button.onclick = () => router.redirect(<!-- @include: @shared/payload.md -->)
```

#### `State` содержит расширенный `Payload` и хранится реактивно

<!-- @include: @shared/introduction/stateInComponents.md -->

:::info
Оператор "non-null assertion" безопасен, если только один `Config` использует этот компонент страницы.
:::

## Конвертация

Браузер работает с URL в [закодированном формате](https://developers.google.com/maps/url-encoding),
поэтому **Reactive Route** имеет встроенные механизмы кодирования и декодирования, которые запускаются
в процессе конвертации структур.

Рассмотрим процесс инициализации первого редиректа:

<!-- @include: @shared/introduction/initEncoded.md -->

Роутер не понимает строковый формат, так как его нет в выше описанных структурах. 

Для конвертации существует метод <Link to="api/router#router-urltopayload">router.urlToPayload</Link>,
который очищает URL от всего, что не требуется для создания `Payload`, декодирует значения, 
запускает валидаторы и возвращает понятный роутеру формат.

:::tip Важно
В валидаторы попадают **декодированные** значения:

`id: (value) => console.log(value)` покажет не `with%20space` а `with space`
:::

В итоге получился валидный `Payload`, на вызывается редирект:

<!-- @include: @shared/introduction/initDecodedRedirect.md -->

### Схема работы редиректа

- выполняется исследование причины редиректа. В данном случае `reason = 'new_config'`, так как
до этого у роутера не было ни одного `State`
- выполняется `beforeLeave` предыдущего `Config` (его не было, поэтому пропускается)
- выполняется `beforeEnter` желаемого `Config` с выполнением всей логики и прохождением
цепочки редиректов
- для итогового `Config` загружается js-чанк (если включен code-splitting) с компонентом и другими экспортами
- создается `State` с помощью <Link to="api/router#router-payloadtostate">router.payloadToState</Link>
и кладется в соответствующий `router.state[config.name]`, в данном случае `router.state.user`

<!-- @include: @shared/introduction/initEncodedState.md -->

:::info 
Если из URL необходимо было **декодировать** значения, то при создании `State` происходит
обратный процесс — **кодирование**, что видно в свойствах `pathname`, `search` и `url`.

Также вызывается валидация динамических `params` и `query`
:::

- если включена синхронизация с History API (по умолчанию — включена для браузерного окружения),
то вызывается `pushState / replaceState` для синхронизации текущего `State.url` и URL браузера

Этот процесс обеспечивает безопасность и предотвращает попадание в приложение некорректных значений.