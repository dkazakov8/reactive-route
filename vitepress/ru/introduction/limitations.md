# Ограничения

## Nested configs

Reactive Route никогда не будет поддерживать вложенные `Config`. Ключевые идеи библиотеки — типобезопасность
и простота структур. Представьте такую конфигурацию:

<!-- @include: @snippets/advanced/nested.md -->

Хотя технически можно решить коллизии имен и валидаторов, кардинально усложнив `Payload`, сделать это
типобезопасно не получится, а частичные `State` и неясный жизненный цикл ухудшат DX.

У Nested configs много пограничных случаев:

- Нужно держать в уме, как будет рендериться дерево компонентов и как связаны компоненты.
- Неясно, как будут вести себя жизненные циклы. Будет ли вызван `beforeEnter` второго уровня при 
изменении `params` или `query` третьего уровня, и наоборот? Как написать стабильный поток загрузки данных и валидации авторизации?
- Рефакторинг превращается в кошмар — при любых изменениях нужно переписывать структуру компонентов, 
менять способ загрузки данных и обновлять все внутренние ссылки. Без помощи TypeScript.
- Страдает DX: отсутствие поддержки "Find Usages" или быстрой навигации в IDE, ограниченная поддержка 
автодополнения, нетипизированные редиректы по строкам путей и т.д.

Однако у них есть возможность автоматической генерации breadcrumbs, и если в проекте их много — лучше 
выбрать роутер с их поддержкой. Как правило, к преимуществам Nested configs еще причисляется удобство
работы с Layouts, но в Reactive Route с ними так же удобно работать, как показано в [Use-cases](/ru/guide/advanced#layouts).

## Hash

В библиотеке не поддерживаются `hash`-параметры, и они принудительно очищаются при редиректах.
Reactive Route ориентирован на современные стандарты браузерного History API и не подходит для 
приложений, требующих `hash`-маршрутизации (например, старые версии Electron).

В библиотеке есть два мощных механизма для динамических параметров — `query` и `params`. 
Они типизированы, участвуют в жизненных циклах, валидируются и способны эффективно решать задачи, для
которых традиционно использовался `hash` (скролл до элемента `#anchor` и хранение UI-состояния). Третий 
механизм лишь усложнит проектирование и сделает состояние приложения фрагментированным.
