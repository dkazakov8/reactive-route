# Причины ограничений

Хотя большинство библиотек для роутинга предпочитает копировать весь функционал,
который есть у конкурентов, и жестко привязывать к своей экосистеме, **Reactive Route** 
сохраняет фокус на:

- реактивном хранении данных о текущей странице в `router.state[name]`
- асинхронной подготовке к открытию следующей страницы
- удобном интерфейсе для редиректов (т.к. нативный `window.pushState('/new-path?phone=1234')` не
  типизирован, выполняется синхронно и не работает на сервере или в виджетах)
- независимости от фреймворка

Позитивным трендом сейчас является TypeScript, поэтому весь функционал,
не совместимый со статической типизацией, отсутствует. Сюда входят опциональные
параметры в пути, JSX-объявление `<Route path="untyped[?-partial]-string/:id/:id/:id">`, 
файловый роутинг `posts/$postId/$/$.tsx` и другие практики,
разрушающие типобезопасность и структуру.

## Nested routes / Динамические роуты

Представьте такую валидную с точки зрения ряда альтернативных роутеров
конфигурацию, но которой **никогда не будет в Reactive Route**:

<!-- @include: @shared/introduction/createConfigsNestedDynamic.md -->

Коллизии имен и валидаторов нельзя решить на уровне статического анализа, а редиректы
становятся сложными и ненадежными, без ясного жизненного цикла. 

В роутерах, использующих подобные паттерны, приходится в рантайме решать коллизии, держать в голове 
всю структуру компонентов и их динамики, а рефакторинг требует полного переделывания логики 
редиректов по частичным строкам путей и структуры приложения (без помощи TypeScript).

Также крайне сложно сделать стабильный поток загрузки данных и проверки прав пользователя.
Будет ли вызван `beforeEnter` второго уровня при изменении `params` или `query` третьего уровня, и наоборот?

Разумеется, страдает и DX: отсутствует поддержка "Find Usages" или быстрой навигации в IDE, 
ограниченная поддержка автодополнения, отсутствуют подсказки при описании редиректов.

Таким образом, код выше сразу становится **legacy** и требует экспертных знаний о
проекте, кардинально усложняя развитие кодовой базы, параллельную работу команды и прозрачность.

## Hash / History State

В **Reactive Route не поддерживаются** URL hash и History State, и принудительно очищаются при редиректах.
Их использование усложняет проектирование и делает состояние приложения фрагментированным.

В библиотеке есть два мощных механизма для динамических параметров — `query` и `params`. 
Они типизированы, участвуют в жизненных циклах, валидируются и способны эффективно решать задачи, для
которых традиционно использовался `hash` (скролл до элемента `#anchor` и хранение UI-состояния).

Также **Reactive Route** не привязан к History API, что
позволяет использовать его для встраиваемых виджетов или микрофронтендов. Например,
можно сохранять в Local Storage текущий `router.getActiveState().url`, 
отключив синхронизацию с History API через `router.historySyncStop()`.

Это позволит использовать библиотеку там, где традиционно использовался Hash Routing, собирая
виджеты с полноценным асинхронным роутингом, изолированным от других частей приложения, причем
на любом фреймворке.

## Нестроковые params и query

Так как браузерный URL содержит только строковые значения, в **Reactive Route** нет утилит для
автоматической конвертации в разные типы данных.

<!-- @include: @shared/introduction/noStringConversion.md -->

В этом примере строковые значения проверяются с помощью `validators.numeric`, который либо специфичен
для проекта, либо берется из любой из сотен библиотек для валидации. Подразумевается, что он
уже проверил значение на `NaN`, `Infinite`, `-0` и подтвердил, что 
строка при `Number(params.id)` является корректным числом.

Но само приведение к `Number / Boolean / Object / Array` не встроено в библиотеку и как в примере
выше является ответственностью разработчика. Это позволяет 
использовать структуры любой сложности через собственные механизмы десериализации.

Ряд библиотек имеет встроенные утилиты для приведения значений к определенному типу:

<!-- @include: @shared/introduction/stringConversionLibraries.md -->

Эти механизмы создают иллюзию, что URL может хранить и обрабатывать что-то кроме строк, а подходы
к валидации становятся неверными, что особенно заметно при попытке возложить на роутер автоматическое
приведение к `Object / Array / Date` и парсинг сложных структур.
