<script setup>
import { data } from '@/dynamic.data'
</script>

# Обзор и назначение

<br>
<Badge type="warning">{{ data.version }}</Badge>
<Badge type="info">Размер (core + integration): <span style="color:var(--docsearch-focus-color)">{{ data.sizeForLabel }}</span></Badge>
<Badge type="info">Покрытие: <span style="color:var(--docsearch-focus-color)">{{ data.metrics.coverage }}</span> в <span style="color:var(--docsearch-focus-color)">{{ data.passedTests }}</span> тестах</Badge>

При использовании MobX, реактивности Vue, сигналов Solid.js и других реактивных систем
сложно поддерживать синхронизацию с нереактивными роутерами, которые часто привязаны к UI 
или структуре файлов.

Для решения этой проблемы был создан **Reactive Route**, работающий с любыми
реактивными библиотеками и фреймворками, что значительно облегчает работу с разными стеками. 

Для наиболее распространенных доступны готовые интеграции:

- React + [MobX](https://mobx.js.org/)
- React + [Observable](https://observable.ru/)
- Preact (без compat) + MobX
- Preact (без compat) + Observable
- Solid.js + [реактивность Solid.js](https://docs.solidjs.com/concepts/intro-to-reactivity)
- Solid.js + MobX
- Solid.js + Observable
- Vue + [реактивность Vue](https://vuejs.org/guide/extras/reactivity-in-depth)

## Преимущества

Библиотека следует строгой философии — минимальный размер, максимальная типизация,
обязательная валидация URL-параметров, отказоустойчивость и поддержка SSR.

**Reactive Route** — это отдельный слой роутинга, побуждающий не разбрасывать конфигурацию
по файлам и компонентам. В нем нет редиректов по частичным путям и виртуальной вложенности,
что позволяет использовать статический анализ TypeScript (а значит — автоматический рефакторинг, 
быстрые переходы и автодополнение).

Дерево компонентов в проекте остается чистым, а на структуру папок и
имена файлов не накладывается ограничений.

Асинхронные методы `beforeEnter` и `beforeLeave` позволяют контролировать доступ
и загружать данные в сторы, а `beforeComponentChange` - проектировать модульные архитектуры
с поддержкой code-splitting не только для компонентов страниц, но и для других сущностей (и 
"разрушать" их при переходе на другие страницы), с бесшовной поддержкой SSR.

Разумеется, присутствует first-class поддержка реактивности — отслеживать текущее состояние
можно из любого места, включая компоненты, хуки, глобальные сторы, а благодаря кешированию 
компоненты страниц рендерятся только один раз.

## Поддержка браузеров

Reactive Route использует Dual Packaging (CJS и ESM автоматически выбираются исходя из 
конфигурации проекта) для максимальной совместимости. Для работы без полифиллов необходимы
как минимум Chrome v55, Firefox v52, Safari v10.1 и Node.js v10 если используется SSR.

Основным ограничением является отсутствие 
поддержки [async/await](https://caniuse.com/async-functions) и 
[URLSearchParams](https://caniuse.com/mdn-api_urlsearchparams)
в более старых версиях браузеров.

Вы можете сразу перейти к <Link to="examples">Примерам</Link> для вашего стека или следующей секции 
документации для ознакомления со схемой работы библиотеки.
