// #region introduction-overview

# Обзор и назначение

<script setup>
import { data } from '@/dynamic.data'
</script>

<br>
<Badge type="warning">{{ data.version }}</Badge>
<Badge type="info">Размер (core + integration): <span style="color:var(--docsearch-focus-color)">{{ data.sizeForLabel }}</span></Badge>
<Badge type="info">Покрытие: <span style="color:var(--docsearch-focus-color)">{{ data.metrics.coverage }}</span> в <span style="color:var(--docsearch-focus-color)">{{ data.passedTests }}</span> тестах</Badge>

При использовании MobX, реактивности Vue, сигналов Solid.js и других реактивных систем
сложно поддерживать синхронизацию с нереактивными роутерами, которые часто привязаны к UI 
или структуре файлов.

Для решения этой проблемы был создан **Reactive Route**, работающий с любыми
реактивными библиотеками и фреймворками, что значительно облегчает работу с разными стеками. 

Для наиболее распространенных доступны готовые интеграции:

- React + [MobX](https://mobx.js.org/)
- React + [Observable](https://observable.ru/)
- Preact (без compat) + MobX
- Preact (без compat) + Observable
- Solid.js + [реактивность Solid.js](https://docs.solidjs.com/concepts/intro-to-reactivity)
- Solid.js + MobX
- Solid.js + Observable
- Vue + [реактивность Vue](https://vuejs.org/guide/extras/reactivity-in-depth)

## Преимущества

Библиотека следует строгой философии — минимальный размер, максимальная типизация,
обязательная валидация URL-параметров, отказоустойчивость и поддержка SSR.

**Reactive Route** — это отдельный слой роутинга, побуждающий не разбрасывать конфигурацию
по файлам и компонентам. В нем нет редиректов по частичным путям и виртуальной вложенности,
что позволяет использовать статический анализ TypeScript (а значит — автоматический рефакторинг, 
быстрые переходы и автодополнение + стабильную генерацию с помощью ИИ моделей).

Дерево компонентов в проекте остается чистым, а на структуру папок и
имена файлов не накладывается ограничений.

Асинхронные методы `beforeEnter` и `beforeLeave` позволяют контролировать доступ
и загружать данные в сторы, а `beforeComponentChange` - проектировать модульные архитектуры
с поддержкой code-splitting не только для компонентов страниц, но и для других сущностей (и 
"разрушать" их при переходе на другие страницы), с бесшовной поддержкой SSR.

Разумеется, присутствует first-class поддержка реактивности — отслеживать текущее состояние
можно из любого места, а благодаря кешированию компоненты страниц рендерятся только один раз.

## Поддержка браузеров

**Reactive Route** использует Dual Packaging (CJS и ESM автоматически выбираются исходя из 
конфигурации проекта) для максимальной совместимости. Для работы без полифиллов необходимы
как минимум **Chrome 55**, **Firefox 52**, **Safari 10.1** и **Node.js 10** если используется SSR.

Основным ограничением является отсутствие поддержки [async/await](https://caniuse.com/async-functions) 
и [URLSearchParams](https://caniuse.com/mdn-api_urlsearchparams) в более старых версиях браузеров.

Вы можете сразу перейти к <Link to="examples">Примерам</Link> для вашего стека или следующей секции 
документации для ознакомления со схемой работы библиотеки.

// #endregion introduction-overview

// #region introduction-limitations

# Ограничения

Хотя большинство библиотек для роутинга предпочитает копировать весь функционал,
который есть у конкурентов, и жестко привязывать к своей экосистеме, **Reactive Route**
сохраняет фокус на:

- реактивном хранении данных о текущей странице в `router.state[name]`
- асинхронной подготовке к открытию следующей страницы
- удобном интерфейсе для редиректов (т.к. нативный `window.pushState('/new-path?phone=1234')` не
  типизирован, выполняется синхронно и не работает на сервере или в виджетах)
- независимости от фреймворка

Позитивным трендом сейчас является TypeScript, поэтому весь функционал,
не совместимый со статической типизацией, отсутствует. Сюда входят опциональные
параметры в пути, JSX-объявление `<Route path="untyped[?-partial]-string/:id/:id/:id">`,
файловый роутинг `posts/$postId/$/$.tsx` и другие практики,
разрушающие типобезопасность и структуру.

## Nested routes / Динамические роуты

Представьте такую валидную с точки зрения ряда альтернативных роутеров
конфигурацию, но которой **никогда не будет в Reactive Route**:

<!-- @include: @shared/introduction/createConfigsNestedDynamic.md -->

Коллизии имен и валидаторов нельзя решить на уровне статического анализа, а редиректы
становятся сложными и ненадежными, без ясного жизненного цикла.

В роутерах, использующих подобные паттерны, приходится в рантайме решать коллизии, держать в голове
всю структуру компонентов и их динамики, а рефакторинг требует полного переделывания логики
редиректов по частичным строкам путей и структуры приложения (без помощи TypeScript).

Также крайне сложно сделать стабильный поток загрузки данных и проверки прав пользователя.
Будет ли вызван `beforeEnter` второго уровня при изменении `params` или `query` третьего уровня, и наоборот?

Разумеется, страдает и DX: отсутствует поддержка "Find Usages" или быстрой навигации в IDE,
ограниченная поддержка автодополнения, отсутствуют подсказки при описании редиректов.

Таким образом, код выше сразу становится **legacy** и требует экспертных знаний о
проекте, кардинально усложняя развитие кодовой базы, параллельную работу команды и прозрачность.

## Hash / History State

В **Reactive Route не поддерживаются** URL hash и History State, и принудительно очищаются при редиректах.
Их использование усложняет проектирование и делает состояние приложения фрагментированным.

В библиотеке есть два мощных механизма для динамических параметров — `query` и `params`.
Они типизированы, участвуют в жизненных циклах, валидируются и способны эффективно решать задачи, для
которых традиционно использовался `hash` (скролл до элемента `#anchor` и хранение UI-состояния).

Также **Reactive Route** не привязан к History API, что
позволяет использовать его для встраиваемых виджетов или микрофронтендов. Например,
можно сохранять в Local Storage текущий `router.getActiveState().url`,
отключив синхронизацию с History API через `router.historySyncStop()`.

Это позволит использовать библиотеку там, где традиционно использовался Hash Routing, собирая
виджеты с полноценным асинхронным роутингом, изолированным от других частей приложения, причем
на любом фреймворке.

## Нестроковые params и query

Так как браузерный URL содержит только строковые значения, в **Reactive Route** нет утилит для
автоматической конвертации в разные типы данных.

<!-- @include: @shared/introduction/noStringConversion.md -->

В этом примере строковые значения проверяются с помощью `validators.numeric`, который либо специфичен
для проекта, либо берется из любой из сотен библиотек для валидации. Подразумевается, что он
уже проверил значение на `NaN`, `Infinite`, `-0` и подтвердил, что
строка при `Number(params.id)` является корректным числом.

Но само приведение к `Number / Boolean / Object / Array` не встроено в библиотеку и как в примере
выше является ответственностью разработчика. Это позволяет
использовать структуры любой сложности через собственные механизмы десериализации.

Ряд библиотек имеет встроенные утилиты для приведения значений к определенному типу:

<!-- @include: @shared/introduction/stringConversionLibraries.md -->

Эти механизмы создают иллюзию, что URL может хранить и обрабатывать что-то кроме строк, а подходы
к валидации становятся неверными, что особенно заметно при попытке возложить на роутер автоматическое
приведение к `Object / Array / Date` и парсинг сложных структур.

// #endregion introduction-limitations

// #region introduction-how-works

# Принцип работы

B **Reactive Route** всего три ключевых структуры с четкими зонами использования.
Их понимание значительно облегчит описание сложных сценариев в ваших проектах.

## Структуры

#### `Config` содержит всю логику работы со страницей

<!-- @include: @shared/introduction/extendedUserConfig.md -->

#### `Payload` содержит значения для определенного `Config`

```tsx
button.onclick = () => router.redirect(<!-- @include: @shared/payload.md -->)
```

#### `State` содержит расширенный `Payload` и хранится реактивно

<!-- @include: @shared/introduction/stateInComponents.md -->

:::info
Оператор "non-null assertion" безопасен, если только один `Config` использует этот компонент страницы.
:::

## Конвертация

Браузер работает с URL в [закодированном формате](https://developers.google.com/maps/url-encoding),
поэтому **Reactive Route** имеет встроенные механизмы кодирования и декодирования, которые запускаются
в процессе конвертации структур.

Рассмотрим процесс инициализации первого редиректа:

<!-- @include: @shared/introduction/initEncoded.md -->

Роутер не понимает строковый формат, так как его нет в выше описанных структурах.

Для конвертации существует метод <Link to="api/router#router-urltopayload">router.urlToPayload</Link>,
который очищает URL от всего, что не требуется для создания `Payload`, декодирует значения,
запускает валидаторы и возвращает понятный роутеру формат.

:::tip Важно
В валидаторы попадают **декодированные** значения:

`id: (value) => console.log(value)` покажет не `with%20space` а `with space`
:::

В итоге получился валидный `Payload`, на который вызывается редирект:

<!-- @include: @shared/introduction/initDecodedRedirect.md -->

### Схема работы редиректа

- выполняется исследование причины редиректа. В данном случае `reason = 'new_config'`
- выполняется `beforeLeave` предыдущего `Config` (его не было, поэтому пропускается)
- выполняется `beforeEnter` желаемого `Config` с выполнением всей логики и прохождением
  цепочки редиректов
- для итогового `Config` загружается js-чанк (если включен code-splitting) с компонентом и другими экспортами
- создается `State` с помощью <Link to="api/router#router-payloadtostate">router.payloadToState</Link>
  и кладется в соответствующий `router.state[config.name]`, в данном случае `router.state.user`

<!-- @include: @shared/introduction/initEncodedState.md -->

:::info
Если из URL необходимо было **декодировать** значения, то при создании `State` происходит
обратный процесс — **кодирование**, что видно в свойствах `pathname`, `search` и `url`.

Также вызывается валидация динамических `params` и `query`
:::

- если включена синхронизация с History API (по умолчанию — включена для браузерного окружения),
  то вызывается `pushState / replaceState` для синхронизации текущего `State.url` и URL браузера

Этот процесс обеспечивает безопасность и предотвращает попадание в приложение некорректных значений.

// #endregion introduction-how-works

// #region introduction-first-setup

# Установка и настройка

<!-- @include: @shared/introduction/installPackage.md -->

**Reactive Route** — это npm-пакет без каких-либо зависимостей с отдельными
импортами модулей для бесшовного подключения к имеющейся системе реактивности
на любом фреймворке (React, Preact, Solid, Vue). Настраивать tree-shaking не требуется.

:::info Peer dependencies
Если используется не "коробочная" реактивность фреймворка, должны быть установлены подходящие
реактивные библиотеки (см. <Link to="integration">Интеграции</Link>).
:::

<Accordion title="Карта модулей">

<<< @/modulesMap.ts

</Accordion>

## Создание конфигурации

В терминологии **Reactive Route** описание роута / маршрута и его поведения называется `Config`
и передается в `createConfigs`:

<!-- @include: @shared/introduction/createRouterSingleton.md -->

`loader` ожидает, что компонент страницы будет в экспорте `default`.

При необходимости можно объявлять `path` с переменными `/:id/:name`, в этом случае для каждой
переменной необходим валидатор. Никогда не доверяйте пришедшим в URL данным, особенно если есть SSR.

:::info Не рекомендуется
сразу передавать компонент `loader: () => Promise.resolve({ default: HomePage })`
для исключения циклических импортов
:::

<Accordion title="Передача конфигурации объектом более типобезопасна">

<!-- @include: ./accordion/objectConfigBetter.md -->

</Accordion>

<Accordion title="Использование асинхронного импорта расширяет возможности">

<!-- @include: ./accordion/asyncLoaderBetter.md -->

</Accordion>

<Accordion title="TypeScript 5 автоматически выводит необходимые валидаторы из path">

<!-- @include: @shared/introduction/tsConfigValidation.md -->

</Accordion>

## Экспорт

Рекомендуется использовать Context API для передачи роутера в компоненты.

:::info Но вы можете сами выбрать схему
Экспорт с помощью Singleton-паттерна (как в предыдущем примере) проще
и подходит для CSR-проектов.

В SSR же несколько пользователей могут одновременно зайти на разные страницы,
и Singlton отрендерит html-разметку из последнего текущего состояния, а не нужного конкретному
пользователю, поэтому требуется изоляция в виде контекстов или другого DI.
:::

<!-- @include: @shared/introduction/createRouterContext.md -->

<Accordion title="Наличие `notFound` и `internalError` обязательно">

<!-- @include: ./accordion/errorPages.md -->

</Accordion>

## Запуск

Роутер готов к работе, осталось найти первоначальный `Config`,
который соответствует URL браузера и отобразить компонент страницы.

<!-- @include: @shared/introduction/renderApp.md -->

:::info
Вместо `location.pathname + location.search` можно передавать и `location.href`, то есть полный
URL. Все лишние для работы роутера данные (protocol, domain, port, hash) очищаются автоматически.
:::

// #endregion introduction-first-setup

// #region introduction-comparison

<script setup>
import { data } from '@/dynamic.data';
</script>

# Сравнение

<SizeComparisonChart :data="data" />

:::info Конфигурация
Используется `esbuild` с минификацией и исключением `peerDependencies` участвующих библиотек.
При включении tree shaking в реальных проектах размеры могут быть меньше.

<!-- @include: @shared/introduction/comparisonBuildScript.md -->
:::

<Accordion title="Входные файлы">

<<< @/../scripts/measureApps/reactive-route.ts
<<< @/../scripts/measureApps/mobx-router.ts
<<< @/../scripts/measureApps/vue-router.ts
<<< @/../scripts/measureApps/kitbag.ts
<<< @/../scripts/measureApps/tanstack.ts
<<< @/../scripts/measureApps/react-router.ts
<<< @/../scripts/measureApps/solid-router.ts

</Accordion>

## Функционал

<ComparisonTable
:headers="['', 'Reactive Route', 'Большинство других библиотек']"
:rows="[
['**Типизация**', 'Полная', 'Частичная (из-за динамического объявления и вложенности TS не знает актуальное дерево роутов)'],
['**Реактивность**', 'Любая с Proxy', 'Только для одной библиотеки / отсутствует'],
['**Фреймворк**', 'Любой', 'Один, в редких исключениях - адаптеры для похожих фреймворков (React + Solid.js)'],
['**Жизненный цикл**', 'Асинхронный', 'Синхронный'],
['**Валидация параметров**', 'Обязательна', 'Опциональна / отсутствует'],
['**SSR**', 'Простая настройка', 'Сложная настройка'],
['**Удобство DX**', 'Быстрые переходы, простой авто-рефакторинг, чистая структура', 'Полная структура есть только в рантайме, ручной контроль редиректов по строкам'],
['**Файловая структура**', 'Любая', 'Ограничена при file-based подходе'],
['**Code splitting**', 'Нативный (для компонентов страниц и других экспортов)', 'Частичный / через специфичные утилиты'],
['**Набор готовых компонентов**', 'Только Router', 'Есть'],
['**Dev tools**', 'Нет (но легко логировать активный State)', 'Есть'],
['**Nested configs**', 'Нет', 'Есть'],
['**Wildcards**', 'Нет', 'Есть'],
['**Динамические роуты**', 'Нет', 'Есть'],
['**Опциональные части path**', 'Нет', 'Есть'],
['**File-based**', 'Нет', 'Есть'],
['**Поддержка hash и URL state**', 'Нет', 'Частичная'],
['**Конвертация типов params и query**', 'Нет', 'Частичная'],
]"
/>

// #endregion introduction-comparison
