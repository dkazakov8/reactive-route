<script setup>
import { data } from '../../dynamic.data'
</script>

# Почему Reactive Route?

<br>
<Badge type="warning">{{ data.version }}</Badge>
<Badge type="info">Размер: <span style="color:var(--docsearch-focus-color)">{{ data.size }}</span></Badge>
<Badge type="info">Покрытие: <span style="color:var(--docsearch-focus-color)">{{ data.coverage }}</span> в <span style="color:var(--docsearch-focus-color)">{{ data.passedTests }}</span> тестах</Badge>

Когда вы используете реактивную библиотеку управления состоянием (на основе сигналов или Proxy), интегрировать существующие библиотеки роутинга бывает довольно сложно. Обычно они жестко привязаны к UI (например, на основе JSX) или структуре файлов и имеют собственное нереактивное состояние. В конечном итоге в вашем проекте оказывается два состояния роутинга (или три, включая историю браузера) и постоянная борьба за их синхронизацию.

Кроме того, у вас могут быть микрофронтенды или просто несколько проектов, использующих разные UI-библиотеки (например, React, Solid.js, Vue) и разные системы реактивности (MobX, Observable, сигналы Solid.js, Vue reactive). Намного проще иметь одну библиотеку роутинга с единым подходом для всех этих приложений и чувствовать себя "как дома" при работе с другими технологическими стеками.

Так родилось решение "reactive-first", которое работает с любой UI и реактивной библиотекой. Оно готово как для небольших проектов (с Solid.js оно занимает около 8 КБ и подходит для мобильных проектов или лендингов с SSR), так и для крупных приложений.

## Готов к вашему стеку

В настоящее время Reactive Route предоставляет официальные реализации для:

- React + [MobX](https://mobx.js.org/)
- React + [Observable](https://observable.ru/)
- Preact (без compat) + MobX
- Preact (без compat) + Observable
- Solid.js + [реактивность Solid.js](https://docs.solidjs.com/concepts/intro-to-reactivity)
- Solid.js + MobX
- Solid.js + Observable
- Vue + [реактивность Vue](https://vuejs.org/guide/extras/reactivity-in-depth)

А ядро открыто для вашего собственного стека — достаточно передать соответствующие адаптеры и компонент Router.

## Мощные возможности

- **Жизненный цикл**: Встроенные асинхронные методы `beforeEnter` и `beforeLeave` позволяют контролировать поток навигации, выполнять проверки аутентификации, загружать данные, заполнять сторы, обрабатывать несохраненные изменения, выполнять множественные редиректы.

- **Динамическая загрузка компонентов**: Асинхронные импорты (например, `() => import('./pages/Home')`) позволяют загружать JS-чанки по запросу (когда пользователь переходит на определенную страницу или программно), улучшая производительность приложения. Эта функция зависит от способности вашего сборщика генерировать отдельные чанки.

- **Модульная интеграция данных**: Вы можете экспортировать любые данные со страниц, и они будут доступны через метод `beforeComponentChange`. Это важно для SSR с модульными/доменными сторами или сторами для конкретных страниц, и служит мощным механизмом внедрения зависимостей (Dependency Injection).

- **Server-Side Rendering**: Простой в использовании механизм для предварительного рендеринга страниц на стороне сервера с опциональной загрузкой данных и опциональной очисткой нерелевантных параметров запроса из URL.

- **Строгая валидация**: Каждый динамический параметр из URL (например, `/page/:id/:mode`) и каждый параметр запроса (query parameter) должен иметь валидатор, что предотвращает использование неверных маршрутов и повышает надежность приложения.

- **Безопасность типов**: Всесторонняя поддержка TypeScript для маршрутов, динамических параметров и параметров запроса, обеспечивающая отличный DX с автодополнением. Больше никаких редиректов на нетипизированные строки или ручного поиска при рефакторинге. Это намного лучше, чем во многих популярных библиотеках роутинга, где "абсолютная типобезопасность" означает `string | unknown`.

- **Мечта архитектора**: Роутер — это плоский отдельный слой, который работает с любым фреймворком или вообще без него. Больше никакой логики роутинга, зарытой внутри UI-компонентов и шаблонов. Нет необходимости в AST-парсинге разметки для поиска маршрутов и нет загрязненных деревьев компонентов. Также нет требований к структуре папок или именованию файлов.

- **Оптимизация**: Решение "reactive-first" оптимизирует ререндеринг компонентов и имеет встроенный кэш для различных маршрутов, которые загружают один и тот же компонент (необходимо для имитации поведения "вложенных маршрутов").

- **Стабильность**: Библиотека подтверждена <span style="color:var(--docsearch-focus-color)">{{ data.passedTests }}</span> юнит и E2E тестами, которые запускаются в реальных браузерах с использованием Playwright.

## Поддержка браузеров

Reactive Route поставляется с двойной упаковкой (бандлы CJS и ESM с автоопределением) для максимальной совместимости. Этот список содержит поддерживаемые версии браузеров для распространяемого кода; ваш сборщик может транспилировать его и добавить полифиллы для повышения совместимости.

| Браузер     | Поддерживаемая версия | Ограничивающая функция                                                                                                                      |
|:------------|:----------------------|:--------------------------------------------------------------------------------------------------------------------------------------------|
| **Chrome**  | **> 55**              | `async/await` (v55), `URLSearchParams` (v49) [[1]](https://caniuse.com/async-functions) [[2]](https://caniuse.com/mdn-api_urlsearchparams) |
| **Firefox** | **> 52**              | `async/await` (v52), `URLSearchParams` (v44)                                                                                                |
| **Safari**  | **> 10.1**            | `async/await` (v10.1), `URLSearchParams` (v10.1)                                                                                            |
| **Edge**    | **> 17**              | `async/await` (v15), `URLSearchParams` (v17)                                                                                                |
| **Opera**   | **> 42**              | `async/await` (v42), `URLSearchParams` (v36)                                                                                                |
| **IE**      | **Нет**               |                                                                                                                                             |
| **Node.js** | **> 10**              |                                                                                                                                             |

Готовы попробовать? Если вы опытный разработчик, вы можете сразу перейти к [примерам](/ru/examples/react) для вашего любимого стека — использование интуитивно понятно и просто. Или следуйте руководству [Начало работы](/ru/guide/getting-started) для пошаговых инструкций.
