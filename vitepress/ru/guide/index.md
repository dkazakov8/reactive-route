<script setup>
import { data } from '@/dynamic.data'
</script>

# Зачем Reactive Route?

<br>
<Badge type="warning">{{ data.version }}</Badge>
<Badge type="info">Размер: <span style="color:var(--docsearch-focus-color)">{{ data.metrics.sizes['reactive-route'].compressed }} KB</span></Badge>
<Badge type="info">Покрытие: <span style="color:var(--docsearch-focus-color)">{{ data.coverage }}</span> в <span style="color:var(--docsearch-focus-color)">{{ data.passedTests }}</span> тестах</Badge>

Вы используете реактивное состояние - MobX, реактивность Vue, сигналы Solid.js?
Если да - то сталкивались с проблемой его синхронизации с нереактивными роутерами,
которые часто привязаны к UI разметке или структуре 
файлов, не используют современные возможности типизации и имеют огромный размер.

Вы работаете над проектами на разных стеках? Например, пишете мобильные версии
сайтов на Solid.js (отличный вариант с jsx-шаблонами и встроенной реактивностью
всего в 6 КБ), поддерживаете внутренний проект на React и есть часть систем
на Vue?

Думаю, любой разработчик фронтенда слышал или писал на нескольких фреймворках.
Намного проще иметь одну библиотеку роутинга для всех этих приложений, а не изучать
каждый раз новый набор библиотек и их подходов.

Reactive Route может работать с любой реактивной библиотекой и перечисленными
фреймворками (как и с другими - ядро независимо). Для наиболее популярных
доступны готовые интеграции:

- React + [MobX](https://mobx.js.org/)
- React + [Observable](https://observable.ru/)
- Preact (без compat) + MobX
- Preact (без compat) + Observable
- Solid.js + [реактивность Solid.js](https://docs.solidjs.com/concepts/intro-to-reactivity)
- Solid.js + MobX
- Solid.js + Observable
- Vue + [реактивность Vue](https://vuejs.org/guide/extras/reactivity-in-depth)

## Возможности

- **Мечта разработчика**: отдельный слой роутинга, не разбросанный
по файлам и компонентам. Нет редиректов по частичным path и сложности поиска
по проекту - все связано типами и при любом изменении TS подскажет об ошибке. Нет
раздутого дерева компонентов или требований к структуре папок и именованию файлов.

- **Жизненный цикл**: Встроенные асинхронные методы `beforeEnter` и `beforeLeave` 
дают большой контроль - разрешать ли заходить на эту страницу (например,
неавторизованным) или покидать ее, при необходимости можно загружать данные и 
выполнять последовательные редиректы.

- **Ленивая загрузка**: Асинхронные импорты (например, `() => import('pages/home')`) позволяют 
загружать JS-чанки только когда пользователь переходит на определенную страницу, улучшая 
производительность первого открытия сайта.

- **Модульные экспорты**: Все данные, экспортируемые файлами страниц, доступны в методе `beforeComponentChange`. 
Таким образом можно организовать архитектуру с модульными/постраничными сторами с поддержкой SSR.

- **Серверный рендеринг**: Всего несколько строк кода позволят создавать готовый html на сервере с
опциональной загрузкой данных для каждой страницы и очисткой лишних query параметров.

- **Строгая валидация**: Каждый динамический параметр из URL (например, `/page/:id/:mode`) и 
каждый query параметр должен иметь валидатор, что повышает надежность приложения.

- **Типобезопасность**: Используются современные возможности TypeScript 5 для максимальной статической
валидации и автодополнения. Больше никаких редиректов на нетипизированные строки или ручного поиска 
при рефакторинге. DX кардинально отличается от "абсолютной типобезопасности" популярных библиотек 
роутинга с повсеместными `string | unknown`.

- **Оптимизация**: Решение "reactive-first" оптимизирует ререндеринг компонентов и имеет встроенный 
кэш, имитируя поведение nested routes.

- **Стабильность**: Библиотека прошла <span style="color:var(--docsearch-focus-color)">{{ data.passedTests }}</span> 
unit + E2E тестов, которые запускаются в реальных браузерах с использованием Playwright.

## Поддержка браузеров

Reactive Route использует Dual Packaging (CJS и ESM автоматически выбираются исходя из 
конфигурации проекта) для максимальной совместимости.

Ваш бандлер может транспилировать код библиотеки и добавить полифиллы, чтобы поддержать и более
низкие версии браузеров.

| Браузер     | Поддерживаемые версии | Причина ограничений                                                                                                                        |
|:------------|:----------------------|:-------------------------------------------------------------------------------------------------------------------------------------------|
| **Chrome**  | **> 55**              | `async/await` (v55), `URLSearchParams` (v49) [[1]](https://caniuse.com/async-functions) [[2]](https://caniuse.com/mdn-api_urlsearchparams) |
| **Firefox** | **> 52**              | `async/await` (v52), `URLSearchParams` (v44)                                                                                               |
| **Safari**  | **> 10.1**            | `async/await` (v10.1), `URLSearchParams` (v10.1)                                                                                           |
| **Edge**    | **> 17**              | `async/await` (v15), `URLSearchParams` (v17)                                                                                               |
| **Opera**   | **> 42**              | `async/await` (v42), `URLSearchParams` (v36)                                                                                               |
| **IE**      | **Нет**               |                                                                                                                                            |
| **Node.js** | **> 10**              |                                                                                                                                            |

Готовы попробовать? Если вы опытный разработчик, можете сразу перейти 
к [примерам](/ru/examples/react) для вашего стека — использование достаточно простое. 
Или переходите к следующей секции документации для пошаговой настройки.
