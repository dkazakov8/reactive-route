# Настройка

## Установка

Один пакет включает всё необходимое для использования Reactive Route. В
секции "Интеграция" описаны необходимые peer dependencies в зависимости от стека.

<!-- @include: @/snippets/getting-started/install.md -->

## Карта модулей

<<< @/modulesMap.ts

## Создание роутера и маршрутов

Маршруты `notFound` и `internalError` обязательны для обработки
ошибок в библиотеке, в их конфигурации не допускаются `params` и `query`.

Рекомендуется использовать Context API для передачи роутера в компоненты. Это
позволяет избежать циклических зависимостей, создания нескольких экземпляров и добавляет возможность
SSR.

Пример файла `router.ts` (при необходимости можно объединить с другими контекстами, если они используются):

<!-- @include: @/snippets/getting-started/router.md -->

`loader` ожидает, что компонент страницы будет в экспорте `default`. При необходимости можно
использовать и именованные экспорты или сразу передавать компоненты `loader: () => Promise.resolve({ default: MyComponent })`,
если code splitting не планируется использовать. Однако это добавляет риск возникновения циклических импортов,
поэтому лучше использовать рекомендованный подход.

Уже на этом этапе вы заметите существенные плюсы современной типизации - при объявлении `path: '/user/:id'`
TS автоматически поймет, что здесь присутствует динамический параметр `id` и поможет написать
соответствующий валидатор.

## Рендеринг и проброс контекста

Для примера используется CSR (client-only rendering) с помощью
[router.hydrateFromURL](/ru/guide/router-api.html#router-hydratefromurl). Версия для [SSR](/ru/guide/ssr) очень похожа, но использует 
соответствующий фреймворкам метод `hydrate`.

<!-- @include: @/snippets/getting-started/render.md -->

Всё настроено и готово к использованию. В дальнейшем потребуется только добавлять или редактировать
конфигурацию маршрутов.