# Use-cases

## Цепочки редиректов

Reactive Route поддерживает неограниченное количество редиректов в CSR и SSR.

<!-- @include: @/snippets/redirect-chain.md -->

В этом случае, если пользователь перейдет на `/4`, он будет перенаправлен на `/3`, затем на `/2` и, наконец, на `/1`. 
Промежуточные редиректы не отражаются в истории браузера, а чанки для них не будут загружены.

## Реакции на изменения

Объект [router.state](/ru/guide/router-api#router-state) является **реактивным**, поэтому за изменениями
можно следить в реакциях, например:

<!-- @include: @/snippets/advanced/reactions.md -->

## Nested routes

Reactive Route никогда не будет поддерживать вложенные `Config`. Ключевые идеи библиотеки — типобезопасность
и простота структур. Представьте такую конфигурацию:

<!-- @include: @/snippets/advanced/nested.md -->

Хотя технически можно решить коллизии имен и валидаторов, кардинально усложнив `Payload`, сделать это
типобезопасно не получится, а частичные `State` и неясный жизненный цикл ухудшат DX.

У Nested routes много пограничных случаев:

- Нужно держать в уме, как будет рендериться дерево компонентов и как связаны компоненты.
- Неясно, как будут вести себя жизненные циклы. Будет ли вызван `beforeEnter` второго уровня при 
изменении `params` или `query` третьего уровня, и наоборот? Как написать стабильный поток загрузки данных и валидации авторизации?
- Рефакторинг превращается в кошмар — при любых изменениях нужно переписывать структуру компонентов, 
менять способ загрузки данных и обновлять все внутренние ссылки. Без помощи TypeScript.
- Страдает DX: отсутствие поддержки "Find Usages" или быстрой навигации в IDE, ограниченная поддержка 
автодополнения, нетипизированные редиректы по строкам путей и т.д.

Однако у них есть возможность автоматической генерации breadcrumbs, и если в проекте их много — лучше 
выбрать роутер с их поддержкой. Как правило, к преимуществам Nested routes еще причисляется удобство
работы с Layouts, но в Reactive Route с ними так же удобно работать, как будет показано далее.

## Layouts

Существует три основных способа работы с динамическими компонентами:

1. Вне компонента Router, как описано в [router.getActiveState](/ru/guide/router-api#router-getactivestate)

2. Внутри компонента страницы, реагируя на динамические параметры

<!-- @include: @/snippets/advanced/dashboard.md -->

<!-- @include: @/snippets/advanced/dashboard-example.md -->

3. Также можно установить один и тот же `loader` для нескольких `Config`. В этом случае `beforeComponentChange` 
не будет вызываться, и компонент страницы **не** будет перерендериваться при редиректе между ними. 
Однако активный `State` будет меняться. Этот пример мог бы выглядеть как предыдущий, но выберем подход с реактивной функцией:

<!-- @include: @/snippets/advanced/dashboard-multi.md -->

<!-- @include: @/snippets/advanced/dashboard-multi-example.md -->

Эти три подхода решают немного разные задачи, но служат хорошим примером, как использовать Reactive Route в различных сценариях.