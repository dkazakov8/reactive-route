import{c as a,o as r,j as t,aj as o,a as i,t as n,k as s}from"./chunks/framework.zbNV7tSY.js";const l=JSON.parse('{"size":"1.65 KB"}'),g=JSON.parse('{"title":"Why Reactive Route?","description":"","frontmatter":{},"headers":[],"relativePath":"guide/index.md","filePath":"guide/index.md"}'),d={name:"guide/index.md"},h=Object.assign(d,{setup(p){return(c,e)=>(r(),a("div",null,[e[0]||(e[0]=t("h1",{id:"why-reactive-route",tabindex:"-1"},[i("Why Reactive Route? "),t("a",{class:"header-anchor",href:"#why-reactive-route","aria-label":"Permalink to “Why Reactive Route?”"},"​")],-1)),e[1]||(e[1]=t("p",null,"When you use a reactive state management library (either Signals or Proxy-based) it's usually quite challenging to integrate existing routing libraries. They are usually hard-linked to the UI (e.g., JSX-based) and have their own non-reactive state. Eventually, your project ends up with two routing states and the struggle of keeping them in sync.",-1)),e[2]||(e[2]=t("p",null,`Also, you may have microfrontends or just several projects using different UI libraries (like React, Solid.js, Vue) and different reactivity systems (MobX, Observable, Solid.js signals, Vue reactive). It's much easier to have a single routing library with a unified approach across all these apps. Developers from one tech stack will feel "at home" when working with others, leading to more stable code and faster delivery.`,-1)),e[3]||(e[3]=t("p",null,"So, we need a reactive-first solution that works with any UI and reactive library.",-1)),t("p",null,"Reactive Route is battle-proven both for small projects (Solid.js 5.6 KB + Reactive Route "+n(s(l).size)+" are ready for mobile-only projects or landing pages with SSR) and large-scale applications (50+ pages on React with partial SSR for an unauthorized zone).",1),e[4]||(e[4]=o("",6))]))}});export{g as __pageData,h as default};
